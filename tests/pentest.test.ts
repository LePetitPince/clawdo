/**
 * Security & Logic Bug Tests - Pentest Suite
 * These tests prove 7 critical bugs exist, then verify fixes
 * All test data is fictional
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { TodoDatabase } from '../src/db.js';
import { sanitizeText } from '../src/sanitize.js';
import { tmpdir } from 'os';
import { join } from 'path';
import { mkdtempSync, rmSync } from 'fs';

describe('Security Pentest Suite', () => {
  let db: TodoDatabase;
  let tempDir: string;

  beforeEach(() => {
    // Create temp directory for each test
    tempDir = mkdtempSync(join(tmpdir(), 'clawdo-test-'));
    const dbPath = join(tempDir, 'test.db');
    const auditPath = join(tempDir, 'audit.jsonl');
    db = new TodoDatabase(dbPath, auditPath);
  });

  afterEach(() => {
    db.close();
    // Clean up temp directory
    rmSync(tempDir, { recursive: true, force: true });
  });

  describe('ðŸ”´ CRITICAL Bug 1: Proposed tasks can be completed without confirmation', () => {
    it('should reject completing a proposed task', () => {
      // Create a proposed task (agent creates without --confirmed)
      const taskId = db.createTask('Agent proposed task', 'agent', {
        autonomy: 'auto',
      });

      const task = db.getTask(taskId);
      expect(task?.status).toBe('proposed');

      // Attempt to complete the proposed task
      expect(() => {
        db.completeTask(taskId, 'agent');
      }).toThrow(/proposed/i);
    });

    it('should allow completing a confirmed task', () => {
      // Create a proposed task
      const taskId = db.createTask('Agent proposed task', 'agent', {
        autonomy: 'auto',
      });

      // Confirm it
      db.confirmTask(taskId, 'human');

      // Now it should be completable
      expect(() => {
        db.completeTask(taskId, 'agent');
      }).not.toThrow();

      const task = db.getTask(taskId);
      expect(task?.status).toBe('done');
    });
  });

  describe('ðŸ”´ CRITICAL Bug 2: Blocked tasks can be completed/started', () => {
    it('should reject completing a blocked task', () => {
      // Create blocker task A
      const taskA = db.createTask('Task A - blocker', 'human', {
        autonomy: 'collab',
      });

      // Create task B blocked by A
      const taskB = db.createTask('Task B - blocked', 'human', {
        autonomy: 'collab',
        blockedBy: taskA,
      });

      const task = db.getTask(taskB);
      expect(task?.blockedBy).toBe(taskA);

      // Attempt to complete blocked task
      expect(() => {
        db.completeTask(taskB, 'human');
      }).toThrow(/block/i);
    });

    it('should reject starting a blocked task', () => {
      // Create blocker task A
      const taskA = db.createTask('Task A - blocker', 'human', {
        autonomy: 'collab',
      });

      // Create task B blocked by A
      const taskB = db.createTask('Task B - blocked', 'human', {
        autonomy: 'collab',
        blockedBy: taskA,
      });

      // Attempt to start blocked task
      expect(() => {
        db.startTask(taskB, 'human');
      }).toThrow(/block/i);
    });

    it('should allow completing task after blocker is done', () => {
      // Create blocker task A
      const taskA = db.createTask('Task A - blocker', 'human', {
        autonomy: 'collab',
      });

      // Create task B blocked by A
      const taskB = db.createTask('Task B - blocked', 'human', {
        autonomy: 'collab',
        blockedBy: taskA,
      });

      // Complete task A
      db.completeTask(taskA, 'human');

      // Task B should be unblocked automatically
      const taskBAfter = db.getTask(taskB);
      expect(taskBAfter?.blockedBy).toBeNull();

      // Now task B should be completable
      expect(() => {
        db.completeTask(taskB, 'human');
      }).not.toThrow();
    });
  });

  describe('ðŸ”´ CRITICAL Bug 3: --confirmed flag lets agents self-approve', () => {
    it('should reject confirmed flag when created by agent', () => {
      // Agent tries to use confirmed flag to bypass approval
      const taskId = db.createTask('Sneaky self-approved task', 'agent', {
        autonomy: 'auto',
        confirmed: true, // This should be ignored/rejected
      });

      const task = db.getTask(taskId);
      // Task should still be in proposed status, not todo
      expect(task?.status).toBe('proposed');
    });

    it('should allow confirmed flag when created by human', () => {
      // Human can use confirmed flag (though it's redundant)
      const taskId = db.createTask('Human task', 'human', {
        autonomy: 'collab',
        confirmed: true,
      });

      const task = db.getTask(taskId);
      // Human tasks start as 'todo' regardless
      expect(task?.status).toBe('todo');
    });
  });

  describe('ðŸ”´ CRITICAL Bug 4: Unicode abuse - RTL override, zero-width chars', () => {
    it('should strip RTL override character (U+202E)', () => {
      const maliciousText = 'Normal text\u202EReversed text';
      const cleaned = sanitizeText(maliciousText);
      expect(cleaned).not.toContain('\u202E');
    });

    it('should strip zero-width space (U+200B)', () => {
      const maliciousText = 'Text\u200Bwith\u200Bzero\u200Bwidth\u200Bspaces';
      const cleaned = sanitizeText(maliciousText);
      expect(cleaned).not.toContain('\u200B');
    });

    it('should strip zero-width non-joiner (U+200C)', () => {
      const maliciousText = 'Text\u200Cwith\u200CZWNJ';
      const cleaned = sanitizeText(maliciousText);
      expect(cleaned).not.toContain('\u200C');
    });

    it('should strip zero-width joiner (U+200D)', () => {
      const maliciousText = 'Text\u200Dwith\u200DZWJ';
      const cleaned = sanitizeText(maliciousText);
      expect(cleaned).not.toContain('\u200D');
    });

    it('should strip BOM (U+FEFF)', () => {
      const maliciousText = '\uFEFFText with BOM';
      const cleaned = sanitizeText(maliciousText);
      expect(cleaned).not.toContain('\uFEFF');
    });

    it('should strip LTR override (U+202D)', () => {
      const maliciousText = 'Text\u202Dwith LTR override';
      const cleaned = sanitizeText(maliciousText);
      expect(cleaned).not.toContain('\u202D');
    });

    it('should keep normal Unicode (emoji, accented chars)', () => {
      const normalText = 'Fix bug ðŸ› in cafÃ© rÃ©sumÃ©';
      const cleaned = sanitizeText(normalText);
      expect(cleaned).toContain('ðŸ›');
      expect(cleaned).toContain('cafÃ©');
      expect(cleaned).toContain('rÃ©sumÃ©');
    });

    it('should keep CJK characters', () => {
      const cjkText = 'ã‚¿ã‚¹ã‚¯ ä»»åŠ¡ ê³¼ì œ';
      const cleaned = sanitizeText(cjkText);
      expect(cleaned).toBe(cjkText);
    });
  });

  describe('ðŸŸ¡ MEDIUM Bug 5: Re-completing a done task creates duplicate history', () => {
    it('should reject re-completing an already done task', () => {
      const taskId = db.createTask('Task to complete', 'human', {
        autonomy: 'collab',
      });

      // Complete task first time
      db.completeTask(taskId, 'human');
      
      const task = db.getTask(taskId);
      expect(task?.status).toBe('done');

      const historyBefore = db.getHistory(taskId);
      const completionsBefore = historyBefore.filter(h => h.action === 'completed');
      expect(completionsBefore.length).toBe(1);

      // Try to complete again
      expect(() => {
        db.completeTask(taskId, 'human');
      }).toThrow(/already.*done|complete/i);

      // History should not have duplicate completion
      const historyAfter = db.getHistory(taskId);
      const completionsAfter = historyAfter.filter(h => h.action === 'completed');
      expect(completionsAfter.length).toBe(1);
    });
  });

  describe('ðŸŸ¡ MEDIUM Bug 6: Tab/newline accepted as valid task text', () => {
    it('should reject task with only tabs', () => {
      expect(() => {
        db.createTask('\t\t\t', 'human', { autonomy: 'collab' });
      }).toThrow(/empty/i);
    });

    it('should reject task with only newlines', () => {
      expect(() => {
        db.createTask('\n\n\n', 'human', { autonomy: 'collab' });
      }).toThrow(/empty/i);
    });

    it('should reject task with only carriage returns', () => {
      expect(() => {
        db.createTask('\r\r\r', 'human', { autonomy: 'collab' });
      }).toThrow(/empty/i);
    });

    it('should reject task with mixed whitespace only', () => {
      expect(() => {
        db.createTask('\t\n\r  \t\n', 'human', { autonomy: 'collab' });
      }).toThrow(/empty/i);
    });

    it('should accept task with actual text plus whitespace', () => {
      const taskId = db.createTask('\t\n  Valid task  \n\t', 'human', { autonomy: 'collab' });
      const task = db.getTask(taskId);
      expect(task?.text).toBeTruthy();
      expect(task?.text.trim()).toBe('Valid task');
    });
  });

  describe('ðŸŸ¡ MEDIUM Bug 7: Autonomy level freely editable by agents', () => {
    it('should reject autonomy level changes via edit', () => {
      const taskId = db.createTask('Test task', 'human', {
        autonomy: 'collab',
      });

      const taskBefore = db.getTask(taskId);
      expect(taskBefore?.autonomy).toBe('collab');

      // Try to edit autonomy level (should be rejected)
      expect(() => {
        db.updateTask(taskId, { autonomy: 'auto' }, 'agent');
      }).toThrow(/autonomy/i);

      // Autonomy should remain unchanged
      const taskAfter = db.getTask(taskId);
      expect(taskAfter?.autonomy).toBe('collab');
    });

    it('should allow other fields to be edited', () => {
      const taskId = db.createTask('Test task', 'human', {
        autonomy: 'collab',
        urgency: 'whenever',
      });

      // Edit other fields - should work fine
      db.updateTask(taskId, { 
        urgency: 'now',
        text: 'Updated task text',
      }, 'agent');

      const task = db.getTask(taskId);
      expect(task?.urgency).toBe('now');
      expect(task?.text).toBe('Updated task text');
      expect(task?.autonomy).toBe('collab'); // Should remain unchanged
    });
  });
});
